<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap">
    <link rel="stylesheet" href="/css/style.css">
    <title>Rustroneer</title>
    <script>
        function randomizeCapitalization(str) {
            return str.split('').map(char => Math.random() > 0.5 ? char.toUpperCase() : char.toLowerCase()).join('');
        }

        window.onload = function() {
            const bigSideTextElement = document.querySelector('.big-side-text');
            if (bigSideTextElement) {
                
                bigSideTextElement.textContent = randomizeCapitalization(
                    'alexharding'
                    );
            }
        }
    </script>
</head>
<body class="color-scheme-2">
    <div class="grid">
        <div class="grid-item main-column">
            
<article class="content">
    <h1 class="main-heading">Rustroneer</h1>
    <div><div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/LJN3EgiLoIY?si=WCSg9n9OQ3ogh2ls" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
<br>
<p>Rustroneer is a 2D planet generator inspired by <a href="https://www.youtube.com/watch?v=0KXQZG7riEs&amp;t=1s">Astroneer</a>, written in Rust using the <a href="https://bevyengine.org">Bevy</a> game engine.</p>
<br>
<p>My best guess is that Astroneer's procedural generation pipeline is something like:</p>
<br>
<ul>
<li>Generate base planet terrain from voxels using some form of noise, domain warping</li>
<li>Run post processing of some form to add features, hollow out the cave systems</li>
<li>Mesh the voxels using marching cubes</li>
<li>Spawn props such as foliage, decorations (some form of domain meta data must exist so it can determine what to spawn where)</li>
</ul>
<br>
<p>The nice thing about this is that the underlying voxels can be modified at runtime time somewhat trivially, and the marching cubes algorithm is fast enough to run in real time, therefore allowing the player to deform the planet.</p>
<br>
<p>All of these concepts have 2D equivalents. So I thought I'd have a go at creating a 2D version in the style of my <a href="/posts/SpaceGame">Space Game</a> prototype.</p>
<br>
<p>In my version, I do the following:</p>
<br>
<ul>
<li>Generate base planet with 2D voxels (hereafter referred to as pixels) based on a perlin noise function calculating distance from the center of the map, to give me basic surface terrain.</li>
<li>Run a cellular automata algorithm to generate cave systems.</li>
<li>Identify each cafe using a flood fill algorithm, which gives me meta data about each cave such as the center of each cave</li>
<li>Use a MST to generate a tunnel system, and subtract that from the pixel map</li>
<li>Run image processing (blur, domain warp)</li>
<li>Mesh using marching squares, also generate colliders</li>
<li>Render with a simple line shader</li>
</ul>
<br>
<p>As the underlying map is just an image, this allows the user to modify the terrain like in Astroneer by effectively painting on the image and rerunning the meshing algorithm. Pretty neat!</p>
<br>
<p>Next steps:</p>
<ul>
<li>More sophisticated terrain, with regions like mountain, hill, flat plains, etc</li>
<li>Vegetation and other props, which respect biomes</li>
<li>Creatures that can interact with the environment, burrow into the terrain etc</li>
<li>Water (not sure how...)</li>
<li>Optimize the meshing so that the whole thing doesn't get re-meshed every time a change happens, which will allow for much bigger and higher detail worlds</li>
<li>Build for wasm so I can run it here!</li>
</ul>
</div>
</article>

        </div>
        
        <div class="grid-item sidebar-column">
            <div class="social-links">
                <div><a href="https://bsky.app/profile/alexharding.bsky.social">Bluesky</a></div>
                <div><a href="mailto:alexander.harding@gmail.com">Email</a></div>
                <div><a href="https://www.instagram.com/wash_your_manipulators/">Instagram</a></div>
            </div>
            <a href="/" class="big-side-text">alexharding</a>
        </div>
    </div>
</body>
</html>
